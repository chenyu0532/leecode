```
动态规划：主要是把大的问题拆分成一个个小的子问题，且能够从小的子问题推导出原问题的解
	同时需要满足下面两个条件：
		(1) 最优子结构性: 既所拆分的子问题的解是最优解。
		(2) 子问题重叠性质: 既在求解的过程当中，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的解题效率

典型的示例就是 
	(1) 斐波拉契数列
 	function feiBoLaQie(n) {
        let val = [];
        for(let i =0 ;i<=n;i++){
            val[i] = 0;
        }
        if (n==1 || n==2){
            return 1;
        } else{
            val[1] = 1;
            val[2] = 2;
            for (let j =3; j<=n;j++){
                val[j] = val[j-1] + val[j-2];
            }
        }
        return val[n-1];
    }

    (2) 爬梯子
    假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

	function climbStairs(n) {
       if (n === 1 || n === 2) {
           return n;
       }
       var ways = [];
       ways[0] = 1;
       ways[1] = 2;
       for(var i=2; i<n; i++){
           ways[i]=ways[i-1] + ways[i-2];
       }
       return ways[n-1];
   }

   (3)所有路径
   	一个机器人位于一个 m x n 网格的左上角
	机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角
	问总共有多少条不同的路径？

	走到右下（m,n）有多少种走法，且只能往右和往下走，那么如果要走到（m,n），那么我们的上一步只能是（m-1,n）或者（m,n-1），所以走到（m,n）的所有走法就是走到（m-1,n）的所有走法+走到(m,n-1)的所有走法，即可以得到状态转换方程：
	ways[m][n] = ways[m-1][n] + ways[m][n-1]
	但是，这个问题还有一些其他的问题限制需要我们考虑到，即走到上侧和左侧的时候，只会有一个方向的走法，需要对这个进行限制




